package codegen

import (
	"fmt"
	"strings"
	"time"

	"hooktm/internal/store"
)

func RenderFromWebhook(wh store.Webhook, lang string) (string, error) {
	lang = strings.ToLower(strings.TrimSpace(lang))
	switch lang {
	case "go", "ts", "typescript", "python", "py", "php", "ruby":
	default:
		return "", fmt.Errorf("unsupported lang: %s", lang)
	}

	prov := strings.ToLower(strings.TrimSpace(wh.Provider))
	if prov == "" {
		prov = "unknown"
	}
	meta := metaHeader(lang, wh, prov)

	switch prov {
	case "stripe":
		return meta + stripeTemplate(lang, wh), nil
	case "github":
		return meta + githubTemplate(lang, wh), nil
	default:
		return meta + genericHMACTemplate(lang, wh), nil
	}
}

func metaHeader(lang string, wh store.Webhook, prov string) string {
	ts := time.UnixMilli(wh.CreatedAt).UTC().Format("2006-01-02 15:04:05 UTC")
	event := wh.EventType
	if strings.TrimSpace(event) == "" {
		event = "(unknown)"
	}
	switch normalizeLang(lang) {
	case "go":
		return fmt.Sprintf("// Generated by HookTM from captured %s webhook\n// Event: %s\n// Captured: %s\n\n", prov, event, ts)
	case "ts":
		return fmt.Sprintf("// Generated by HookTM from captured %s webhook\n// Event: %s\n// Captured: %s\n\n", prov, event, ts)
	case "python":
		return fmt.Sprintf("# Generated by HookTM from captured %s webhook\n# Event: %s\n# Captured: %s\n\n", prov, event, ts)
	case "php":
		return fmt.Sprintf("<?php\n// Generated by HookTM from captured %s webhook\n// Event: %s\n// Captured: %s\n\n", prov, event, ts)
	case "ruby":
		return fmt.Sprintf("# Generated by HookTM from captured %s webhook\n# Event: %s\n# Captured: %s\n\n", prov, event, ts)
	default:
		return ""
	}
}

func stripeTemplate(lang string, wh store.Webhook) string {
	switch normalizeLang(lang) {
	case "go":
		return `package webhook

import (
	"fmt"
	"os"

	"github.com/stripe/stripe-go/v76"
	"github.com/stripe/stripe-go/v76/webhook"
)

func ValidateStripeWebhook(payload []byte, sigHeader string) (*stripe.Event, error) {
	secret := os.Getenv("STRIPE_WEBHOOK_SECRET")
	if secret == "" {
		return nil, fmt.Errorf("STRIPE_WEBHOOK_SECRET not set")
	}

	event, err := webhook.ConstructEvent(payload, sigHeader, secret)
	if err != nil {
		return nil, fmt.Errorf("signature verification failed: %w", err)
	}
	return &event, nil
}
`
	case "ts":
		return `import Stripe from "stripe";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: "2024-06-20" });

export function validateStripeWebhook(payload: string | Buffer, signature: string): Stripe.Event {
  const secret = process.env.STRIPE_WEBHOOK_SECRET;
  if (!secret) throw new Error("STRIPE_WEBHOOK_SECRET not set");
  return stripe.webhooks.constructEvent(payload, signature, secret);
}
`
	case "python":
		return `import os
import stripe

def validate_stripe_webhook(payload: bytes, signature: str) -> stripe.Event:
    secret = os.environ.get("STRIPE_WEBHOOK_SECRET")
    if not secret:
        raise ValueError("STRIPE_WEBHOOK_SECRET not set")
    return stripe.Webhook.construct_event(payload, signature, secret)
`
	case "php":
		return `use Stripe\Webhook;

function validateStripeWebhook(string $payload, string $sigHeader): \Stripe\Event {
    $secret = getenv("STRIPE_WEBHOOK_SECRET");
    if (!$secret) {
        throw new \RuntimeException("STRIPE_WEBHOOK_SECRET not set");
    }
    return Webhook::constructEvent($payload, $sigHeader, $secret);
}
`
	case "ruby":
		return `require "stripe"

def validate_stripe_webhook(payload, sig_header)
  secret = ENV["STRIPE_WEBHOOK_SECRET"]
  raise "STRIPE_WEBHOOK_SECRET not set" if !secret || secret.empty?
  Stripe::Webhook.construct_event(payload, sig_header, secret)
end
`
	default:
		return ""
	}
}

func githubTemplate(lang string, wh store.Webhook) string {
	switch normalizeLang(lang) {
	case "go":
		return `package webhook

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"strings"
)

func ValidateGitHubWebhook(payload []byte, sigHeader string) error {
	secret := os.Getenv("GITHUB_WEBHOOK_SECRET")
	if secret == "" {
		return fmt.Errorf("GITHUB_WEBHOOK_SECRET not set")
	}

	if !strings.HasPrefix(sigHeader, "sha256=") {
		return fmt.Errorf("invalid signature format")
	}

	sig, err := hex.DecodeString(strings.TrimPrefix(sigHeader, "sha256="))
	if err != nil {
		return fmt.Errorf("invalid signature encoding: %w", err)
	}

	mac := hmac.New(sha256.New, []byte(secret))
	mac.Write(payload)
	expected := mac.Sum(nil)

	if !hmac.Equal(sig, expected) {
		return fmt.Errorf("signature mismatch")
	}
	return nil
}
`
	case "ts":
		return `import crypto from "crypto";

export function validateGitHubWebhook(payload: Buffer, sigHeader: string): boolean {
  const secret = process.env.GITHUB_WEBHOOK_SECRET;
  if (!secret) throw new Error("GITHUB_WEBHOOK_SECRET not set");
  if (!sigHeader.startsWith("sha256=")) throw new Error("invalid signature format");

  const sig = Buffer.from(sigHeader.slice("sha256=".length), "hex");
  const expected = crypto.createHmac("sha256", secret).update(payload).digest();
  return crypto.timingSafeEqual(sig, expected);
}
`
	case "python":
		return `import hmac
import hashlib
import os

def validate_github_webhook(payload: bytes, signature: str) -> bool:
    secret = os.environ.get("GITHUB_WEBHOOK_SECRET")
    if not secret:
        raise ValueError("GITHUB_WEBHOOK_SECRET not set")
    if not signature.startswith("sha256="):
        raise ValueError("invalid signature format")
    expected = "sha256=" + hmac.new(secret.encode(), payload, hashlib.sha256).hexdigest()
    return hmac.compare_digest(signature, expected)
`
	case "php":
		return `function validateGitHubWebhook(string $payload, string $sigHeader): bool {
    $secret = getenv("GITHUB_WEBHOOK_SECRET");
    if (!$secret) throw new \RuntimeException("GITHUB_WEBHOOK_SECRET not set");
    if (strpos($sigHeader, "sha256=") !== 0) throw new \RuntimeException("invalid signature format");

    $expected = "sha256=" . hash_hmac("sha256", $payload, $secret);
    return hash_equals($sigHeader, $expected);
}
`
	case "ruby":
		return `require "openssl"

def validate_github_webhook(payload, sig_header)
  secret = ENV["GITHUB_WEBHOOK_SECRET"]
  raise "GITHUB_WEBHOOK_SECRET not set" if !secret || secret.empty?
  raise "invalid signature format" unless sig_header.start_with?("sha256=")

  expected = "sha256=" + OpenSSL::HMAC.hexdigest("sha256", secret, payload)
  Rack::Utils.secure_compare(sig_header, expected)
end
`
	default:
		return ""
	}
}

func genericHMACTemplate(lang string, wh store.Webhook) string {
	switch normalizeLang(lang) {
	case "go":
		return `package webhook

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"strings"
)

// Generic template: provider uses HMAC-SHA256 over the raw request body.
// Adjust header parsing and signing scheme to match your provider.
func ValidateWebhookHMAC(payload []byte, sigHeader string) error {
	secret := os.Getenv("WEBHOOK_SECRET")
	if secret == "" {
		return fmt.Errorf("WEBHOOK_SECRET not set")
	}

	// Example header format: "sha256=<hex>"
	if !strings.HasPrefix(sigHeader, "sha256=") {
		return fmt.Errorf("invalid signature format")
	}
	sig, err := hex.DecodeString(strings.TrimPrefix(sigHeader, "sha256="))
	if err != nil {
		return fmt.Errorf("invalid signature encoding: %w", err)
	}

	mac := hmac.New(sha256.New, []byte(secret))
	mac.Write(payload)
	expected := mac.Sum(nil)
	if !hmac.Equal(sig, expected) {
		return fmt.Errorf("signature mismatch")
	}
	return nil
}
`
	case "ts":
		return `import crypto from "crypto";

export function validateWebhookHMAC(payload: Buffer, sigHeader: string): boolean {
  const secret = process.env.WEBHOOK_SECRET;
  if (!secret) throw new Error("WEBHOOK_SECRET not set");

  // Example header format: "sha256=<hex>"
  if (!sigHeader.startsWith("sha256=")) throw new Error("invalid signature format");
  const sig = Buffer.from(sigHeader.slice("sha256=".length), "hex");
  const expected = crypto.createHmac("sha256", secret).update(payload).digest();
  return crypto.timingSafeEqual(sig, expected);
}
`
	case "python":
		return `import hmac
import hashlib
import os

def validate_webhook_hmac(payload: bytes, signature: str) -> bool:
    secret = os.environ.get("WEBHOOK_SECRET")
    if not secret:
        raise ValueError("WEBHOOK_SECRET not set")
    # Example header format: "sha256=<hex>"
    if not signature.startswith("sha256="):
        raise ValueError("invalid signature format")
    expected = "sha256=" + hmac.new(secret.encode(), payload, hashlib.sha256).hexdigest()
    return hmac.compare_digest(signature, expected)
`
	case "php":
		return `function validateWebhookHMAC(string $payload, string $sigHeader): bool {
    $secret = getenv("WEBHOOK_SECRET");
    if (!$secret) throw new \RuntimeException("WEBHOOK_SECRET not set");
    if (strpos($sigHeader, "sha256=") !== 0) throw new \RuntimeException("invalid signature format");
    $expected = "sha256=" . hash_hmac("sha256", $payload, $secret);
    return hash_equals($sigHeader, $expected);
}
`
	case "ruby":
		return `require "openssl"

def validate_webhook_hmac(payload, sig_header)
  secret = ENV["WEBHOOK_SECRET"]
  raise "WEBHOOK_SECRET not set" if !secret || secret.empty?
  raise "invalid signature format" unless sig_header.start_with?("sha256=")

  expected = "sha256=" + OpenSSL::HMAC.hexdigest("sha256", secret, payload)
  Rack::Utils.secure_compare(sig_header, expected)
end
`
	default:
		return ""
	}
}

func normalizeLang(lang string) string {
	switch strings.ToLower(strings.TrimSpace(lang)) {
	case "ts", "typescript":
		return "ts"
	case "py", "python":
		return "python"
	default:
		return strings.ToLower(strings.TrimSpace(lang))
	}
}
